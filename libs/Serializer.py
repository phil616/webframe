import pickle
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad,unpad
import random
import datetime
from base64 import b64encode, b64decode
from .SerializerExceptions import EncryptionError
from core.runtime import syslog as logger


class Serializer:
    """
    Serializer for python object.
    """

    def __init__(self):
        self.__logger = logger
        t_system_ctime = datetime.datetime.now().timestamp()
        random.seed(t_system_ctime)

        self.__AES_MODE = AES.MODE_ECB
        self.__AES_RANDOM_KEY = random.randbytes(16)
        self.__logger.debug(
            f"aes key generated by seed {t_system_ctime}: [AES_MODE {self.__AES_MODE}] {self.__AES_RANDOM_KEY}")
        self.__AES_OBJ = AES.new(self.__AES_RANDOM_KEY, self.__AES_MODE)

        pass

    def obj_to_bin(self, obj: object) -> bytes:
        self.__logger.debug("debug")
        return pickle.dumps(obj)

    def bin_to_char(self, bin_sequence: bytes) -> str:
        return b64encode(bin_sequence).decode("utf8")

    def char_to_bin(self, string: str) -> bytes:
        return b64decode(string)

    def bin_to_object(self, bin_sequence: bytes) -> object:
        return pickle.loads(bin_sequence)

    def encrypt(self, src_bin: bytes, key: bytes = None) -> bytes:
        src_bin = pad(src_bin,AES.block_size)
        if key is None:
            return self.__AES_OBJ.encrypt(src_bin)
        if not len(key) % 16 == 0:
            raise EncryptionError(f"[Length Error] Length should be a multiple of 16 "
                                  f"however input key {key} "
                                  f"has length of {len(key)}", "AES")
        if key:
            aes = AES.new(key=key, mode=self.__AES_MODE)
            return aes.encrypt(src_bin)


    @property
    def AES_KEY(self) -> bytes:
        return self.__AES_RANDOM_KEY

    def decrypt(self, src_bytes: bytes, key: bytes = None) -> bytes:
        if key:
            aes = AES.new(key, self.__AES_MODE)
            return unpad(aes.decrypt(src_bytes),AES.block_size)
        return unpad(self.__AES_OBJ.decrypt(src_bytes),AES.block_size)
